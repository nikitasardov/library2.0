## Конфигурационный файл Sphinx-а для индексации поиска

#######################
#
# Описываем индексы
#
#######################

# Источник-родитель для всех остальных источников.
# Здесь указываются параметры доступа к базе данных сайта
source base
{
    # Тип данных. Доступные типы: mysql, pgsql, mssql, xmlpipe, xmlpipe2, odbc
    type				= mysql

    # Необходимые параметры для подключения к базе данных
    sql_host			= localhost
    sql_user			= root
    sql_pass			= root
    sql_db				= pdlada
    sql_port			= 3306	# опциональный, по умолчанию 3306

	mysql_connect_flags	= 32 	# 32- включение сжатие при обмене данными с БД
	
    # пред-запрос, выполняется перед выполнением основного запроса на получение данных из базы
    # В нашей базе данные хранятся в UTF-8, чтобы поиск по русским символам работал успешно выполним соответсвующий запрос
    sql_query_pre		= SET NAMES utf8
}

# Источник РАЗДЕЛЫ
source partition : base
{
    # запрос, который получает данные документов для поиска
    # первым полем обязательно должен идти уникальный положительный ID документа
    sql_query		= SELECT `p`.`id`, `p`.`id` AS `id_use`, \
							 `pc`.`title`, `pc`.`title` AS `title_use`, \
							 `pc`.`preview`, `pc`.`preview` AS `preview_use`, \
							 `pc`.`content`, `pc`.`content` AS `content_use` \
					  FROM `partition` AS `p`, `partition_content` AS `pc` \
					  WHERE `p`.`visible` = 'Y' AND `p`.`id` = `pc`.`partition_id`

	# поля, по которым может идти группировка, фильтрация и сортировка
	sql_attr_uint	= id_use
	sql_attr_string = title_use
	sql_attr_string = preview_use
	sql_attr_string = content_use
}

# Источник НОВОСТИ
source news : base
{
    sql_query		= SELECT `n`.`id`, `n`.`id` AS `id_use`, \
							 `nc`.`title`, `nc`.`title` AS `title_use`, \
							 `nc`.`preview`, `nc`.`preview` AS `preview_use`, \
							 `nc`.`text` AS `content`, `nc`.`text` AS `content_use` \
					  FROM `news` AS `n`, `news_content` AS `nc` \
					  WHERE `n`.`active` = 'Y' AND `n`.`date` <= UNIX_TIMESTAMP() AND `n`.`id` = `nc`.`news_id`

	sql_attr_uint	= id_use
	sql_attr_string = title_use
	sql_attr_string = preview_use
	sql_attr_string = content_use
}

# Источник ДЕТСКИЕ САДЫ
source subdivisions : base
{
    sql_query		= SELECT `s`.`id`, `s`.`id` AS `id_use`, \
						     CONCAT('Детский сад №', `s`.`numb`, ' ', `s`.`name`) AS `title`, CONCAT('Детский сад №', `s`.`numb`, ' ', `s`.`name`) AS `title_use`, \
							 GROUP_CONCAT(`sa`.`fio`, ' ', `sa`.`position`) AS `preview`, GROUP_CONCAT(`sa`.`fio`, ' ', `sa`.`position`) AS `preview_use`, \
							 CONCAT(`s`.`leader`, ' ', `s`.`phone_one`, ' ', `s`.`phone_two`, ' ', `s`.`view`, ' ', `s`.`program_k`, ' ', `s`.`program_p`, ' ', `s`.`service`, ' ', `s`.`about`, ' ', `s`.`actual_txt`) AS `content`, \
							 CONCAT(`s`.`leader`, ' ', `s`.`phone_one`, ' ', `s`.`phone_two`, ' ', `s`.`view`, ' ', `s`.`program_k`, ' ', `s`.`program_p`, ' ', `s`.`service`, ' ', `s`.`about`, ' ', `s`.`actual_txt`) AS `content_use` \
					  FROM `subdivisions` AS `s`, `subdivisions_admins` AS `sa` \
					  WHERE `s`.`id` = `sa`.`subs_id` AND `s`.`removed` = '0' \
					  GROUP BY `s`.`id`

	sql_attr_uint	= id_use
	sql_attr_string = title_use
	sql_attr_string = preview_use
	sql_attr_string = content_use
}

# Источник ОБЪЯВЛЕНИЯ
source swap : base
{
    # Если поле (например content_use) ни как не заполнить - оно всё равно должно существовать
	sql_query		= SELECT `sw`.`id`, `sw`.`id` AS `id_use`, \
							 CONCAT('Обмен детского сада №', `s`.`numb`, ' ', `s`.`name`) AS `title`, CONCAT('Обмен детского сада №', `s`.`numb`, ' ', `s`.`name`) AS `title_use`, \
							 CONCAT(GROUP_CONCAT('Группа: ', `sg`.`name`, '; Возраст:', `sg`.`years`), ' | ', GROUP_CONCAT(`sa`.`numb`, ' ', `sa`.`name`)) AS `preview`, \
							 CONCAT(GROUP_CONCAT('Группа: ', `sg`.`name`, '; Возраст:', `sg`.`years`), ' | ', GROUP_CONCAT(`sa`.`numb`, ' ', `sa`.`name`)) AS `preview_use`, \
							 CONCAT('') AS `content`, CONCAT('') AS `content_use` \
					  FROM `swap` AS `sw`, `subdivisions` AS `s`, `subdivisions_groups` AS `sg`, `subdivisions_all` AS `sa` \
					  WHERE `sw`.`subs_id` = `s`.`id` AND `sg`.`id` IN (`sw`.`group_id`) AND \
					        `sw`.`validation` = 1 AND `sw`.`validation_key` = '' AND `sw`.`removed` = 0 AND `sa`.`id` IN (`sw`.`subs_all_id`) \
					  GROUP BY `sw`.`id` \

	sql_attr_uint	= id_use
	sql_attr_string = title_use
	sql_attr_string = preview_use
	sql_attr_string = content_use
}

#######################
#
# Описываем индексы
#
#######################

# Индекс разделов
index partition
{
    # Источник данных для индексирования
    source            = partition

    # Адрес, где будут хранится данные индекса
    path            = C:\server\sphinx\search_conf\pdlada\indexes\partition

    # Индекс с учетом морфологии
    morphology        = stem_enru

    # Минимальная длина слова для индексации
    min_word_len        = 2

    # Кодировка
    charset_table  = 0..9, A..Z->a..z, _, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+401->U+451, U+451
    blend_chars    = &, ., +, U+23
    min_infix_len  = 2
    index_exact_words = 1
    html_strip     = 1
}

# Индекс новостей
index news
{
    # Источник данных для индексирования
    source            = news

    # Адрес, где будут хранится данные индекса
    path            = C:\server\sphinx\search_conf\pdlada\indexes\news

    # Индекс с учетом морфологии
    morphology        = stem_enru

    # Минимальная длина слова для индексации
    min_word_len        = 2

    # Кодировка
    charset_table  = 0..9, A..Z->a..z, _, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+401->U+451, U+451
    blend_chars    = &, ., +, U+23
    min_infix_len  = 2
    index_exact_words = 1
    html_strip     = 1
}

# Индекс детских садов
index subdivisions
{
    # Источник данных для индексирования
    source            = subdivisions

    # Адрес, где будут хранится данные индекса
    path            = C:\server\sphinx\search_conf\pdlada\indexes\subdivisions

    # Индекс с учетом морфологии
    morphology        = stem_enru

    # Минимальная длина слова для индексации
    min_word_len        = 2

    # Кодировка
    charset_table  = 0..9, A..Z->a..z, _, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+401->U+451, U+451
    blend_chars    = &, ., +, U+23
    min_infix_len  = 2
    index_exact_words = 1
    html_strip     = 1
}

# Индекс объявлений
index swap
{
    # Источник данных для индексирования
    source            = swap

    # Адрес, где будут хранится данные индекса
    path            = C:\server\sphinx\search_conf\pdlada\indexes\swap

    # Индекс с учетом морфологии
    morphology        = stem_enru

    # Минимальная длина слова для индексации
    min_word_len        = 2

    # Кодировка
    charset_table  = 0..9, A..Z->a..z, _, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+401->U+451, U+451
    blend_chars    = &, ., +, U+23
    min_infix_len  = 2
    index_exact_words = 1
    html_strip     = 1
}

#######################
#
# Настройки индексатора
#
#######################

indexer
{
	# Лимит памяти, который может использавать демон-индексатор
	mem_limit			= 128M
}

#######################
#
# Настройка демона-поисковика
#
#######################

searchd
{
    # Какой порт и какой протокол "слушает" служба
    listen            = localhost:9316:mysql41

    # Лог-файл демона
    log            = C:\server\sphinx\search_conf\pdlada\searchd.log

    # Лог поисковых запросов
    query_log        = C:\server\sphinx\search_conf\pdlada\query.log

    # Файл, в который сохраняется PID-процесса при запуске
    pid_file        = C:\server\sphinx\search_conf\pdlada\searchd.pid
}